It is a client side JS library.
It creates a VIRTUAL DOM in memory.
Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.
React only changes what needs to be changed.
It is all about building modern reactive user interfaces for the web.
Declarative, component-focused approach.

React can be used to control parts of HTML pages or entire pages.
'Widget' approach on a multi-page-application.
Some pages are still rendered on and served by a backend server.
Here some part of the page in controlled by react.

React can also used to control the entire frontend of a web application.
Single page application (SPA) approach.
Server only sends one HTML page. therafter, React takes over and control the UI.

Elements are the smallest building block of React apps.
An element describes what you want to see on the screen.
In '<div id="root"></div>', the root here is called DOM Node because everything inside it will be managed by React DOM.
Therefore we render a React element into a root DOM Node.
React elements are immutable. i.e. once you create an element you cant change it children or attributes.
But we can update the UI is to create a new element


React Componenets are made of element(s).
React is all about components.
We build these individual components and then we tell react how to compose them together into a final user interface.
Classes or functions are used for creating components in React.
Componenets gives features like reuseability and seperation of concerns.

Mostly react is all about combining HTML and JAVASCRIPT together and then we can also add css but that's not the focus of React.
React uses declarative approach which defines the desired target state(s) and let react figure out the actual Javascript DOM instructions.
And then react figures out which element should be update, delete or displyed on the webpage.

JSX - JavaScript XML
It converts HTML tags into react elements. 
In react we must have one root element per return statement / per JSX statement. We cannot use two <div></div> inside one return statement.
But we can create a div inside a div. i.e. there must be only one main div and inside this main div we can mave multiple divs.
We can store JSX content in variables.
After compilation, JSX expressions becomes regular JavaScript function calls.

A component cannot use data stored in other components.
Props in react are simple properties that we can use for outter components, just the same as we use in HTML components.
A parent compenent owns the prop and cannot be changed by the child component.
We can use props to share the data between two or more compenents.

we have a distinct props object for every component and for every instance of some component.       

The process of building an user interface from smaller building blocks is called composition in React.
Composition are generally used as "Wrapper components" that add certain styling around the wrapped components.
We cannot use our custom components as wrappers around other kind of content.
having content inside a custom component does not work as same as default html tags.

So to build such wrappers components we use children props
props.children contains all the content which is specified between the opening tag and closing tag of our custom components.


Lists & Keys :-
A “key” is a special string attribute you need to include when creating lists of elements.
Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity.
Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name.

Forms :-
<input type="text">, <textarea> and <select> accepts a value attribute that you can use to implement a controlled component.
preventDefault is called on the event when submitting the form to prevent a browser reload/refresh.
We can use useState hook to get the information provided/written in the form by any user at a particular state.










States and lisiting to user events helps us to change the content/interact with the page.
State in React -
States in the component changes over time. The changes in the state can be done by a user or can be a system event.
A state represents the component's local state or information. We can only modify the state inside that compenent

useState() -->
Syntax :- const[current_state, stateUpdateFunction] = useState(default_value / initial_State);
We pass useState() a default value to useState() as a parameter.
Now, there are two ways through which we can pass our default value to useState.
1. Directly hardcoded values
   Eg. useState(4)
   If we pass the value in this way, At every re-render the useState will be passed the same hardcoded value as the default value.
2. passing a function
   Eg. useState(() => {here we can pass the default value/function})
   If we pass the default value in this way, the useState will be passed the default value only once i.e. at the very first time when the component is rendered.
And it returns a array with 2 values [state(currentstate), function_which_allows_us_to_update_the_state].
The function which is returned by useState() is used to update the state. This function takes a callback function as an parameter.
And the callback function returned by useState() contains previous state as an parameter by which we can update the current state. 
Remember that we can also directly update the current state without taking/using the previous state but it much safer to use the previous state.
**If ur current state update is dependent upon the previous state then it it compulsory to use previous state.

There is a difference while dealing with useState() when we pass the default state as an object.
Whenever we update the value the object it doesnt merge the new state update with the previous state, instead it overrides it.
i.e if our object has more than one values inside it and we update only few of them then after rerendering the values, the values which are not updated are vanised from the object.
And only updated ones stays.
To avoid this we use spread operator, so we can also add the un-updated values to the updated ones.
Other way of doing this is that instead of using object and passing it to one useState() hooks for multiple states.
We can create multiple useState() hooks for multiple states. Hence we avoid the clashing of states.

It registers the state for a specified component instance.
i.e. If we have used the component(function) for multiple times, then for each of them this useState function will create a seperate state.
Hence when each of the components is called it creates a different states for each of them.
That is the reason why after updating one component the others are not affected because each one has seperate state.
REACT SCHEDULES STATE UPDATES, IT DOESNT PERFORMS THEM INSTANTLY.
Using state we can implement 2 way binding which means that for inputs we just dont listen to changes but also pass a new value back to the input. 
So we can reset or change the values
We are passing data from child compenent to parent component by passing this data to the function we got from parent class. 
This is called lifting up of state/data.


MOVING DATA FROM CHILD COMPONENT TO PARENT COMPONENT --> 
We can do this by using props and get a function from parent compenent into child component and then passing the date into that component.


Working with FRAGMENTS, PORTALS, REFS
LIMITATION OF JSX :-->
1. We cannot render 2 JSX elements next to each other. i.e. we cannot return more than one root JSX elements from the return statement.

To avoid using multiple divs / creating div soup we use fragments. 
FRAGMENTS allows us to write neat and clean code.


useEffect() --> 
Syntax :- useEffect(() => {
               The code written here will execute every time this hook executes.
          },[this array will contain some variables and this hooks will only execute when the values passed in the array will change]);

This hooks will perfrom some operations when something/side effect happens.
You must add all "things" you use in your effect function,"things" that could change because your component (or some parent component) re-rendered.
userEffect runs after completion of every components rendering cycle, IF WE DONT PASS THE SECOND ARGUMENT WHICH IS AN ARRAY.
But if you pass the second argument as an array(empty array) then the effect function will run for the first time, but not for the subsequent render cycle.
And if you pass any dependencies in the array then this effect function will run whenever the dependencies is present or valid.
Now, suppose your dependencie(s) is/are some properties of an object then we must only pass that properties of that object instead of passing the whole object in dependency array.
To pass the properties of an object we can use object destructuring or we pass the properties by using dot operator in dependency array.


useReducer -->
Syntax :- const [current_state, dispatch] = useReducer(reducer_function, initial_State);
The initial_State mostly is an object as we deal with more complex states.
The reducer_function accepts 2 values and returns 1. The reducer function accepts the current state and returns the new state. 
Depending on the action the reducer function will perform operations on the current state resulting in the new state.
Syntax of reducer_function :-  function reducer(current_state, action){
                                    return new_state
                               }
The current_state and the action can be normal values or can be object.
The useReducer hook returns 2 values, one is the current state and the other one is dispatch function. 
This dispatch function helps us to use a particular action on reducer_function. We pass the action we want to perform as an parameter to dispatch function.
We can also pass a second paramter in the dispatch function known as payload which helps us to pass all need variables to the reducer function.
It is usally preferred to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous state.
It allows functional components in React to access reducer functions form your statemanagement.


In react we have a concept called react context which allows us to manage kind of beind the scenes in react such that we are able to directly change it
from any component  in out APP and directly pass it to any other componenent in our APP wihout building such a props chain.
Now, to use context we need to provided which is basically telling react that to component which are wrapperd with this context can use it.
And while using we need to consume it which means u need to hook it / listen it 
We can lisiten using AuthContext.Consumer or using a hook (useContext)



React hooks can be recongnized by the fact that they start with the word 'use'.
**React hooks can only be used with functional components. We cannot use them with class components.**
React hooks must be executed in the same order as they are defined after every single re-render.
i.e. we cannot use hooks inside any conditional statement, or inside any loops, or inside anything.
They must be defined at the top level of our function and not be nested/inside anything.
And all these hooks must be only called inside of react components.
They can't be called outside of component functions and they also should't called inside a nested functions.
Basic hooks :--
 1. useState()
 2. useEffect()
 3. useReducer() : Replacement to useState(). For more complex and powerful state management















!#####################################!SOME GOOD RESOURCES!#################################!
useState vs useref :- https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/#what-causes-re-rendering
